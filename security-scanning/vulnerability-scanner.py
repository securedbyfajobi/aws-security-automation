#!/usr/bin/env python3
"""
Advanced Vulnerability Scanner for AWS Security Automation
Integrates multiple security tools for comprehensive vulnerability assessment
"""

import os
import sys
import json
import yaml
import asyncio
import logging
import subprocess
from datetime import datetime
from typing import Dict, List, Any, Optional
from dataclasses import dataclass, asdict
from pathlib import Path

import boto3
import requests
from botocore.exceptions import ClientError


@dataclass
class Vulnerability:
    """Vulnerability data structure"""
    id: str
    title: str
    severity: str
    description: str
    affected_resource: str
    resource_type: str
    region: str
    remediation: str
    cvss_score: Optional[float] = None
    cve_ids: Optional[List[str]] = None
    discovered_at: Optional[str] = None
    status: str = "open"


@dataclass
class ScanResult:
    """Scan result data structure"""
    scan_type: str
    scan_id: str
    started_at: str
    completed_at: Optional[str]
    status: str
    vulnerabilities: List[Vulnerability]
    summary: Dict[str, int]
    metadata: Dict[str, Any]


class VulnerabilityScanner:
    """Enhanced vulnerability scanner with multiple tool integration"""

    def __init__(self, config_path: str = "/etc/security-automation/config.yaml"):
        self.config = self._load_config(config_path)
        self.logger = self._setup_logging()
        self.aws_session = boto3.Session(
            region_name=self.config.get('aws', {}).get('region', 'eu-west-2')
        )
        self.scan_results = []

    def _load_config(self, config_path: str) -> Dict[str, Any]:
        """Load configuration from YAML file"""
        try:
            with open(config_path, 'r') as f:
                return yaml.safe_load(f)
        except FileNotFoundError:
            return self._get_default_config()

    def _get_default_config(self) -> Dict[str, Any]:
        """Return default configuration"""
        return {
            'aws': {'region': 'eu-west-2'},
            'scanning': {
                'enable_inspector': True,
                'enable_security_hub': True,
                'enable_config': True,
                'enable_guardduty': True,
                'enable_custom_checks': True,
                'enable_container_scanning': True,
                'enable_network_scanning': True
            },
            'vulnerability_feeds': {
                'nvd_api_key': os.environ.get('NVD_API_KEY'),
                'mitre_cve_feed': True,
                'aws_security_bulletins': True
            },
            'notification': {
                'sns_topic': os.environ.get('SECURITY_SNS_TOPIC'),
                'slack_webhook': os.environ.get('SLACK_WEBHOOK')
            }
        }

    def _setup_logging(self) -> logging.Logger:
        """Setup logging configuration"""
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler('/var/log/security-automation/vulnerability-scanner.log'),
                logging.StreamHandler()
            ]
        )
        return logging.getLogger(__name__)

    async def run_comprehensive_scan(self, scan_scope: str = "all") -> List[ScanResult]:
        """Run comprehensive vulnerability scan across all enabled services"""
        self.logger.info(f"Starting comprehensive vulnerability scan: {scan_scope}")

        scan_tasks = []

        # AWS Service Scans
        if self.config['scanning'].get('enable_inspector', True):
            scan_tasks.append(self.scan_inspector_v2())

        if self.config['scanning'].get('enable_security_hub', True):
            scan_tasks.append(self.scan_security_hub())

        if self.config['scanning'].get('enable_config', True):
            scan_tasks.append(self.scan_config_compliance())

        if self.config['scanning'].get('enable_guardduty', True):
            scan_tasks.append(self.scan_guardduty_findings())

        # Custom Security Scans
        if self.config['scanning'].get('enable_custom_checks', True):
            scan_tasks.append(self.run_custom_security_checks())

        # Container and Network Scans
        if self.config['scanning'].get('enable_container_scanning', True):
            scan_tasks.append(self.scan_container_vulnerabilities())

        if self.config['scanning'].get('enable_network_scanning', True):
            scan_tasks.append(self.scan_network_vulnerabilities())

        # Execute all scans concurrently
        results = await asyncio.gather(*scan_tasks, return_exceptions=True)

        # Filter successful results
        successful_results = []
        for result in results:
            if isinstance(result, ScanResult):
                successful_results.append(result)
            elif isinstance(result, Exception):
                self.logger.error(f"Scan failed: {result}")

        self.scan_results = successful_results

        # Generate comprehensive report
        await self.generate_comprehensive_report()

        # Send notifications for critical findings
        await self.send_critical_notifications()

        return successful_results

    async def scan_inspector_v2(self) -> ScanResult:
        """Scan using AWS Inspector V2"""
        self.logger.info("Starting Inspector V2 scan")

        inspector = self.aws_session.client('inspector2')
        scan_id = f"inspector-{datetime.now().isoformat()}"
        started_at = datetime.now().isoformat()

        vulnerabilities = []

        try:
            # Enable Inspector V2 if not already enabled
            try:
                inspector.enable(
                    accountIds=[self.aws_session.client('sts').get_caller_identity()['Account']],
                    resourceTypes=['EC2', 'ECR']
                )
            except ClientError as e:
                if 'AccessDeniedException' not in str(e):
                    self.logger.warning(f"Could not enable Inspector: {e}")

            # Get findings
            paginator = inspector.get_paginator('list_findings')

            for page in paginator.paginate():
                for finding in page.get('findings', []):
                    vulnerability = Vulnerability(
                        id=finding.get('findingArn', '').split('/')[-1],
                        title=finding.get('title', 'Unknown Vulnerability'),
                        severity=finding.get('severity', 'UNKNOWN'),
                        description=finding.get('description', ''),
                        affected_resource=finding.get('resources', [{}])[0].get('id', 'Unknown'),
                        resource_type=finding.get('type', 'Unknown'),
                        region=finding.get('awsAccountId', 'Unknown'),
                        remediation=finding.get('remediation', {}).get('recommendation', {}).get('text', ''),
                        cvss_score=finding.get('inspectorScore', 0.0),
                        discovered_at=finding.get('firstObservedAt', started_at),
                        status=finding.get('status', 'ACTIVE').lower()
                    )
                    vulnerabilities.append(vulnerability)

        except ClientError as e:
            self.logger.error(f"Inspector V2 scan failed: {e}")

        # Generate summary
        summary = self._generate_summary(vulnerabilities)

        return ScanResult(
            scan_type="inspector_v2",
            scan_id=scan_id,
            started_at=started_at,
            completed_at=datetime.now().isoformat(),
            status="completed",
            vulnerabilities=vulnerabilities,
            summary=summary,
            metadata={"service": "inspector", "version": "v2"}
        )

    async def scan_security_hub(self) -> ScanResult:
        """Scan Security Hub findings"""
        self.logger.info("Starting Security Hub scan")

        securityhub = self.aws_session.client('securityhub')
        scan_id = f"securityhub-{datetime.now().isoformat()}"
        started_at = datetime.now().isoformat()

        vulnerabilities = []

        try:
            paginator = securityhub.get_paginator('get_findings')

            for page in paginator.paginate(
                Filters={
                    'WorkflowStatus': [{'Value': 'NEW', 'Comparison': 'EQUALS'}],
                    'RecordState': [{'Value': 'ACTIVE', 'Comparison': 'EQUALS'}]
                }
            ):
                for finding in page.get('Findings', []):
                    vulnerability = Vulnerability(
                        id=finding.get('Id', ''),
                        title=finding.get('Title', 'Security Hub Finding'),
                        severity=finding.get('Severity', {}).get('Label', 'UNKNOWN'),
                        description=finding.get('Description', ''),
                        affected_resource=finding.get('Resources', [{}])[0].get('Id', 'Unknown'),
                        resource_type=finding.get('Resources', [{}])[0].get('Type', 'Unknown'),
                        region=finding.get('Region', 'Unknown'),
                        remediation=finding.get('Remediation', {}).get('Recommendation', {}).get('Text', ''),
                        discovered_at=finding.get('FirstObservedAt', started_at),
                        status='open' if finding.get('Workflow', {}).get('Status') == 'NEW' else 'resolved'
                    )
                    vulnerabilities.append(vulnerability)

        except ClientError as e:
            self.logger.error(f"Security Hub scan failed: {e}")

        summary = self._generate_summary(vulnerabilities)

        return ScanResult(
            scan_type="security_hub",
            scan_id=scan_id,
            started_at=started_at,
            completed_at=datetime.now().isoformat(),
            status="completed",
            vulnerabilities=vulnerabilities,
            summary=summary,
            metadata={"service": "securityhub"}
        )

    async def scan_config_compliance(self) -> ScanResult:
        """Scan AWS Config compliance rules"""
        self.logger.info("Starting Config compliance scan")

        config_client = self.aws_session.client('config')
        scan_id = f"config-{datetime.now().isoformat()}"
        started_at = datetime.now().isoformat()

        vulnerabilities = []

        try:
            # Get compliance details for all rules
            rules = config_client.describe_config_rules()

            for rule in rules.get('ConfigRules', []):
                rule_name = rule['ConfigRuleName']

                try:
                    compliance = config_client.get_compliance_details_by_config_rule(
                        ConfigRuleName=rule_name
                    )

                    for result in compliance.get('EvaluationResults', []):
                        if result['ComplianceType'] == 'NON_COMPLIANT':
                            resource_id = result.get('EvaluationResultIdentifier', {}).get('EvaluationResultQualifier', {}).get('ResourceId', 'Unknown')
                            resource_type = result.get('EvaluationResultIdentifier', {}).get('EvaluationResultQualifier', {}).get('ResourceType', 'Unknown')

                            vulnerability = Vulnerability(
                                id=f"config-{rule_name}-{resource_id}",
                                title=f"Config Rule Violation: {rule_name}",
                                severity="MEDIUM",
                                description=rule.get('Description', f"Resource {resource_id} is non-compliant with rule {rule_name}"),
                                affected_resource=resource_id,
                                resource_type=resource_type,
                                region=self.aws_session.region_name,
                                remediation=f"Review and remediate {rule_name} compliance issue for {resource_type}",
                                discovered_at=result.get('ResultRecordedTime', started_at).isoformat() if isinstance(result.get('ResultRecordedTime'), datetime) else started_at,
                                status='open'
                            )
                            vulnerabilities.append(vulnerability)

                except ClientError as e:
                    self.logger.warning(f"Could not get compliance details for {rule_name}: {e}")

        except ClientError as e:
            self.logger.error(f"Config compliance scan failed: {e}")

        summary = self._generate_summary(vulnerabilities)

        return ScanResult(
            scan_type="config_compliance",
            scan_id=scan_id,
            started_at=started_at,
            completed_at=datetime.now().isoformat(),
            status="completed",
            vulnerabilities=vulnerabilities,
            summary=summary,
            metadata={"service": "config"}
        )

    async def scan_guardduty_findings(self) -> ScanResult:
        """Scan GuardDuty findings"""
        self.logger.info("Starting GuardDuty scan")

        guardduty = self.aws_session.client('guardduty')
        scan_id = f"guardduty-{datetime.now().isoformat()}"
        started_at = datetime.now().isoformat()

        vulnerabilities = []

        try:
            # Get detectors
            detectors = guardduty.list_detectors()

            for detector_id in detectors.get('DetectorIds', []):
                # Get findings
                findings_response = guardduty.list_findings(
                    DetectorId=detector_id,
                    FindingCriteria={
                        'Criterion': {
                            'service.archived': {
                                'Eq': ['false']
                            }
                        }
                    }
                )

                if findings_response.get('FindingIds'):
                    findings_details = guardduty.get_findings(
                        DetectorId=detector_id,
                        FindingIds=findings_response['FindingIds']
                    )

                    for finding in findings_details.get('Findings', []):
                        vulnerability = Vulnerability(
                            id=finding.get('Id', ''),
                            title=finding.get('Title', 'GuardDuty Finding'),
                            severity=finding.get('Severity', 0.0),
                            description=finding.get('Description', ''),
                            affected_resource=finding.get('Resource', {}).get('InstanceDetails', {}).get('InstanceId', 'Unknown'),
                            resource_type=finding.get('Type', 'Unknown'),
                            region=finding.get('Region', 'Unknown'),
                            remediation=f"Investigate and remediate GuardDuty finding: {finding.get('Type', 'Unknown')}",
                            discovered_at=finding.get('CreatedAt', started_at),
                            status='open'
                        )
                        vulnerabilities.append(vulnerability)

        except ClientError as e:
            self.logger.error(f"GuardDuty scan failed: {e}")

        summary = self._generate_summary(vulnerabilities)

        return ScanResult(
            scan_type="guardduty",
            scan_id=scan_id,
            started_at=started_at,
            completed_at=datetime.now().isoformat(),
            status="completed",
            vulnerabilities=vulnerabilities,
            summary=summary,
            metadata={"service": "guardduty"}
        )

    async def run_custom_security_checks(self) -> ScanResult:
        """Run custom security checks"""
        self.logger.info("Starting custom security checks")

        scan_id = f"custom-{datetime.now().isoformat()}"
        started_at = datetime.now().isoformat()

        vulnerabilities = []

        # Custom checks
        custom_checks = [
            self._check_s3_public_buckets,
            self._check_iam_unused_roles,
            self._check_security_groups_open_ports,
            self._check_ec2_unencrypted_volumes,
            self._check_rds_public_snapshots,
            self._check_lambda_outdated_runtimes,
            self._check_cloudtrail_configuration
        ]

        for check in custom_checks:
            try:
                check_vulnerabilities = await check()
                vulnerabilities.extend(check_vulnerabilities)
            except Exception as e:
                self.logger.error(f"Custom check {check.__name__} failed: {e}")

        summary = self._generate_summary(vulnerabilities)

        return ScanResult(
            scan_type="custom_checks",
            scan_id=scan_id,
            started_at=started_at,
            completed_at=datetime.now().isoformat(),
            status="completed",
            vulnerabilities=vulnerabilities,
            summary=summary,
            metadata={"checks_run": len(custom_checks)}
        )

    async def scan_container_vulnerabilities(self) -> ScanResult:
        """Scan container vulnerabilities using multiple tools"""
        self.logger.info("Starting container vulnerability scan")

        scan_id = f"container-{datetime.now().isoformat()}"
        started_at = datetime.now().isoformat()
        vulnerabilities = []

        # Scan ECR images
        ecr_vulns = await self._scan_ecr_images()
        vulnerabilities.extend(ecr_vulns)

        # Scan running containers with Trivy
        trivy_vulns = await self._scan_with_trivy()
        vulnerabilities.extend(trivy_vulns)

        # Scan with Grype
        grype_vulns = await self._scan_with_grype()
        vulnerabilities.extend(grype_vulns)

        summary = self._generate_summary(vulnerabilities)

        return ScanResult(
            scan_type="container_vulnerabilities",
            scan_id=scan_id,
            started_at=started_at,
            completed_at=datetime.now().isoformat(),
            status="completed",
            vulnerabilities=vulnerabilities,
            summary=summary,
            metadata={"tools_used": ["ecr", "trivy", "grype"]}
        )

    async def scan_network_vulnerabilities(self) -> ScanResult:
        """Scan network vulnerabilities"""
        self.logger.info("Starting network vulnerability scan")

        scan_id = f"network-{datetime.now().isoformat()}"
        started_at = datetime.now().isoformat()
        vulnerabilities = []

        # Network security scans
        nmap_vulns = await self._run_nmap_scan()
        vulnerabilities.extend(nmap_vulns)

        # VPC Flow Logs analysis
        flow_log_vulns = await self._analyze_vpc_flow_logs()
        vulnerabilities.extend(flow_log_vulns)

        summary = self._generate_summary(vulnerabilities)

        return ScanResult(
            scan_type="network_vulnerabilities",
            scan_id=scan_id,
            started_at=started_at,
            completed_at=datetime.now().isoformat(),
            status="completed",
            vulnerabilities=vulnerabilities,
            summary=summary,
            metadata={"tools_used": ["nmap", "vpc_flow_logs"]}
        )

    def _generate_summary(self, vulnerabilities: List[Vulnerability]) -> Dict[str, int]:
        """Generate vulnerability summary statistics"""
        summary = {
            'total': len(vulnerabilities),
            'critical': 0,
            'high': 0,
            'medium': 0,
            'low': 0,
            'unknown': 0,
            'open': 0,
            'resolved': 0
        }

        for vuln in vulnerabilities:
            severity = vuln.severity.upper()
            if severity in ['CRITICAL', 'VERY_HIGH']:
                summary['critical'] += 1
            elif severity == 'HIGH':
                summary['high'] += 1
            elif severity == 'MEDIUM':
                summary['medium'] += 1
            elif severity == 'LOW':
                summary['low'] += 1
            else:
                summary['unknown'] += 1

            if vuln.status == 'open':
                summary['open'] += 1
            else:
                summary['resolved'] += 1

        return summary

    async def generate_comprehensive_report(self):
        """Generate comprehensive vulnerability report"""
        self.logger.info("Generating comprehensive vulnerability report")

        report = {
            'scan_metadata': {
                'generated_at': datetime.now().isoformat(),
                'scan_count': len(self.scan_results),
                'total_vulnerabilities': sum(len(result.vulnerabilities) for result in self.scan_results)
            },
            'executive_summary': self._generate_executive_summary(),
            'scan_results': [asdict(result) for result in self.scan_results],
            'recommendations': self._generate_recommendations(),
            'compliance_status': self._assess_compliance_status()
        }

        # Save report
        report_path = f"/var/log/security-automation/vulnerability-report-{datetime.now().strftime('%Y%m%d-%H%M%S')}.json"
        with open(report_path, 'w') as f:
            json.dump(report, f, indent=2, default=str)

        self.logger.info(f"Comprehensive report saved to {report_path}")

        return report

    def _generate_executive_summary(self) -> Dict[str, Any]:
        """Generate executive summary"""
        all_vulns = []
        for result in self.scan_results:
            all_vulns.extend(result.vulnerabilities)

        summary = self._generate_summary(all_vulns)

        return {
            'total_vulnerabilities': summary['total'],
            'critical_high_count': summary['critical'] + summary['high'],
            'risk_score': self._calculate_risk_score(summary),
            'top_vulnerability_types': self._get_top_vulnerability_types(all_vulns),
            'most_affected_resources': self._get_most_affected_resources(all_vulns)
        }

    async def send_critical_notifications(self):
        """Send notifications for critical vulnerabilities"""
        critical_vulns = []
        for result in self.scan_results:
            for vuln in result.vulnerabilities:
                if vuln.severity.upper() in ['CRITICAL', 'VERY_HIGH']:
                    critical_vulns.append(vuln)

        if critical_vulns and self.config.get('notification', {}).get('sns_topic'):
            await self._send_sns_notification(critical_vulns)

        if critical_vulns and self.config.get('notification', {}).get('slack_webhook'):
            await self._send_slack_notification(critical_vulns)

    # Additional helper methods would be implemented here
    # (Implementation details for custom checks, container scanning, etc.)


if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="AWS Security Vulnerability Scanner")
    parser.add_argument("--scope", default="all", help="Scan scope: all, aws, containers, network")
    parser.add_argument("--config", default="/etc/security-automation/config.yaml", help="Configuration file path")
    parser.add_argument("--output", default="/var/log/security-automation/", help="Output directory")

    args = parser.parse_args()

    scanner = VulnerabilityScanner(args.config)

    # Run the scanner
    loop = asyncio.get_event_loop()
    results = loop.run_until_complete(scanner.run_comprehensive_scan(args.scope))

    print(f"Vulnerability scan completed. Found {sum(len(r.vulnerabilities) for r in results)} vulnerabilities.")
    print(f"Results saved to {args.output}")